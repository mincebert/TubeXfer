*BASIC
NEW
AUTO
REM>TubeXfer2
:
DIM code% 500,params% 11
OSBYTE=&FFF4
OSASCI=&FFE3
TUBECALL=&406
TUBEID=&10 : REM our ID
TUBEXFERBBC=&FEE5
TUBEXFERELK=&FCE5
USERV=&200
:
REM need 2+11 bytes in zeropage
scratch=&70
parambuf=scratch+2
:
iocode%=&2000 : REM could be FNoshwm but this is safe for all
:
FOR pass%=0 TO 1
P%=iocode%
O%=code%
:
[ OPT 4+2*pass%
CMP #&E0 \ OSWORD &E0
BEQ xfer
JMP (olduserv)
:
.olduserv
EQUW 0
:
.xfer
\ store param addr in scratch
STX scratch
STY scratch+1
:
LDY #0
LDA (scratch),Y \ #send bytes
TAY
DEY
.paramcopyloop
LDA (scratch),Y
STA parambuf,Y
DEY
BPL paramcopyloop
:
.tubeclaim
LDA #&C0+TUBEID
JSR TUBECALL
BCC tubeclaim
:
\ skip 256 byte xfer if <256
LDA parambuf+10
BEQ xfer2
:
.xfer256
LDA #6 \ 256 byte 2>IO
\ 2nd proc addr -> YX
LDX #(parambuf+3) MOD 256
LDY #(parambuf+3) DIV 256
JSR TUBECALL
:
\ need to wait >=19us = 38cy
\ could adjust for below
LDX #8
.wait19loop
DEX \ 2cy
BNE wait19loop \ 3cy
:
LDY #0
.xfer256loop
\ need to wait >=10us = 20cy
NOP \ 2cy
NOP
NOP
NOP
NOP
.elkpatch1
LDA TUBEXFERBBC
STA (parambuf+7),Y \ 6cy
INY \ 2cy
BNE xfer256loop \ 3cy
:
INC parambuf+4 \ 2nd 3MSB
BNE xfer256inc
INC parambuf+5 \ 2nd 2MSB
BNE xfer256inc
INC parambuf+6 \ 2nd MSB
.xfer256inc
INC parambuf+8 \ IO MSB
DEC parambuf+10 \ size MSB
BNE xfer256
:
.xfer2
\ skip if no <256 bytes
LDA parambuf+9
BEQ tuberelease
:
LDA #2 \ 256 byte 2>IO
\ 2nd proc addr -> YX
LDX #(parambuf+3) MOD 256
LDY #(parambuf+3) DIV 256
JSR TUBECALL
:
\ count xferred
LDY #0
:
.xfer2loop
\ wait >=24us = 48 cycles
\ could allow for above block
LDX #10
.wait24loop
DEX
BNE wait24loop
:
.elkpatch2
LDA TUBEXFERBBC
STA (parambuf+7),Y
.elkpatch3
LDA TUBEXFERBBC
INY
CPY parambuf+9
BEQ tuberelease
STA (parambuf+7),Y
INY
CPY parambuf+9
BNE xfer2loop
:
.tuberelease
LDA #&80+TUBEID
JSR TUBECALL
RTS
:
\ end address for IO proc code
.end
:
\ EXEC addr - install routine
.exec
\ check Tube present
LDA #234
LDX #0
LDY #&FF
JSR OSBYTE
CPX #&FF
BEQ alreadycheck
\ Tube not present - print error
LDX #&FF
.notubeloop
INX
LDA notubemsg,X
JSR OSASCI
CMP #&0D
BNE notubeloop
RTS
:
.alreadycheck
LDA USERV
CMP #iocode% MOD 256
BNE hwcheck
LDA USERV+1
CMP #iocode% DIV 256
BNE hwcheck
\ already patched - print error
LDX #&FF
.alreadyloop
INX
LDA alreadymsg,X
JSR OSASCI
CMP #&0D
BNE alreadyloop
RTS
:
.hwcheck
\ if BBC, skip patching tubexfer
LDA #0
LDX #1
JSR OSBYTE
CPX #0
BNE bbchook
:
\ patch tubexfer for Electron
LDX #&FF
.elkmsgloop
INX
LDA elkmsg,X
BEQ elkpatch
JSR OSASCI
JMP elkmsgloop
.elkpatch
LDX #&FF
.elkpatchloop
INX
LDA elkpatchtbl,X
STA scratch
INX
LDA elkpatchtbl,X
STA scratch+1
LDY #1 : \ addr after opcode
LDA #TUBEXFERELK MOD 256
STA (scratch),Y
INY
LDA #TUBEXFERELK DIV 256
STA (scratch),Y
INX
LDA elkpatchtbl,X
BEQ elkpatchloop
JMP uservhook
:
.bbchook
LDX #&FF
.bbchookmsgloop
INX
LDA bbcmsg,X
BEQ uservhook
JSR OSASCI
JMP bbchookmsgloop
:
.uservhook
\ hook USERV to catch OSWORD
PHP
SEI
PHA
LDA USERV
STA olduserv
LDA #iocode% MOD 256
STA USERV
LDA USERV+1
STA olduserv+1
LDA #iocode% DIV 256
STA USERV+1
PLA
PLP
LDX #&FF
.hookedmsgloop
INX
LDA hookedmsg,X
JSR OSASCI
CMP #&0D
BNE hookedmsgloop
RTS
:
.elkpatchtbl
EQUW elkpatch1
EQUB 0
EQUW elkpatch2
EQUB 0
EQUW elkpatch3
EQUB &FF
:
.notubemsg
EQUS "No Tube present!"
EQUB &0D
:
.alreadymsg
EQUS "Already installed!"
EQUB &0D
:
.elkmsg
EQUS "Electron"
EQUB 0
.bbcmsg
EQUS "BBC"
EQUB 0
.hookedmsg
EQUS " version installed"
EQUB &0D
]
:
NEXT
codelen%=P%-iocode%
:
saveparams$=STR$~(code%)+"+"+STR$~(codelen%)+" "+STR$~(exec OR &FFFF0000)+" "+STR$~(iocode% OR &FFFF0000)
PRINT "*SAVE ... ";saveparams$
END
:
DEFPROCsave(filename$)
OSCLI("SAVE "+filename$+" "+saveparams$)
ENDPROC
:
REM gets IO processor OSHWM
DEFFNoshwm
A%=&B4
X%=0
Y%=&FF
=USR(OSBYTE) AND &FF00
