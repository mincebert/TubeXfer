*BASIC
NEW
AUTO
REM>TubeXfr
REM v2.1 (2021-06-19)
:
DIM code% &200,params% 11
OSBYTE=&FFF4
OSASCI=&FFE3
TUBECALL=&406
TUBEID=&10 : REM our ID
TUBEXFERBBC=&FEE5
TUBEXFERELK=&FCE5
USERV=&200
:
REM need 2+11 bytes in zeropage
scratch=&70
parambuf=scratch+2
:
iocode%=&2000 : REM could be FNoshwm but this is safe for all
:
FOR pass%=0 TO 1
P%=iocode%
O%=code%
:
[ OPT 4+2*pass%
CMP #&E0 \ OSWORD &E0
BEQ ourosword
JMP (olduserv)
:
.olduserv
EQUW 0 \ for old USERV addr
:
.ourosword
\ store OSWORD param addr in
\ scratch
STX scratch
STY scratch+1
:
LDY #0
LDA (scratch),Y \ #send bytes
TAY
\ Y=num bytes OSWORD params
DEY
.paramcopyloop
LDA (scratch),Y
STA parambuf,Y
DEY
BPL paramcopyloop
:
\ check the operation code
LDA parambuf+2
CMP #0 \ =2nd>IO
BEQ xfer2io
CMP #&FE \ =unload
BEQ unload
CMP #&FF
BNE unkop
:
.done
\ return with OSWORD handled; we
\ do this for any unknown
\ operation code (inc. &FF=test
\ for presence)
LDA #0
RTS
:
.unload
\ restore USERV
PHP
SEI
LDA olduserv
STA USERV
LDA olduserv+1
STA USERV+1
PLP
JMP done
:
.unkop
BRK
EQUB 1 \ =Out of range
EQUS "Unknown TubeXfer operation"
EQUB 0
:
.xfer2io
.tubeclaim
LDA #&C0+TUBEID
JSR TUBECALL
BCC tubeclaim
:
\ skip 256 byte xfer if <256
LDA parambuf+10
BEQ xfer2
:
.xfer256
LDA #6 \ 256 byte 2>IO
\ 2nd proc addr -> YX
LDX #(parambuf+3) MOD 256
LDY #(parambuf+3) DIV 256
JSR TUBECALL
:
\ need to wait >=19us = 38cy
\ could adjust for below
LDX #8
.wait19loop
DEX \ 2cy
BNE wait19loop \ 3cy
:
LDY #0
.xfer256loop
\ need to wait >=10us = 20cy
NOP \ 2cy each
NOP
NOP
NOP
NOP
.elkpatch1
LDA TUBEXFERBBC
STA (parambuf+7),Y \ 6cy
INY \ 2cy
BNE xfer256loop \ 3cy
:
INC parambuf+4 \ 2nd 3MSB
BNE xfer256inc
INC parambuf+5 \ 2nd 2MSB
BNE xfer256inc
INC parambuf+6 \ 2nd MSB
.xfer256inc
INC parambuf+8 \ IO MSB
DEC parambuf+10 \ size MSB
BNE xfer256
:
.xfer2
\ skip if no <256 bytes
LDA parambuf+9
BEQ tuberelease
:
LDA #2 \ 256 byte 2>IO
\ 2nd proc addr -> YX
LDX #(parambuf+3) MOD 256
LDY #(parambuf+3) DIV 256
JSR TUBECALL
:
\ count xferred
LDY #0
:
.xfer2loop
\ wait >=24us = 48 cycles
\ could allow for above block
LDX #10
.wait24loop
DEX
BNE wait24loop
:
.elkpatch2
LDA TUBEXFERBBC
STA (parambuf+7),Y
.elkpatch3
LDA TUBEXFERBBC
INY
CPY parambuf+9
BEQ tuberelease
STA (parambuf+7),Y
INY
CPY parambuf+9
BNE xfer2loop
:
.tuberelease
LDA #&80+TUBEID
JSR TUBECALL
JMP done
:
\ end address for IO proc code
.end
:
\ EXEC addr - install routine
.exec
\ check Tube present
LDA #234
LDX #0
LDY #&FF
JSR OSBYTE
CPX #&FF
BEQ hwcheck
\ Tube not present - print error
BRK
EQUB 4 \ =Mistake
EQUS "No Tube present"
EQUB 0
:
.hwcheck
\ if BBC, skip patching tubexfer
LDA #0
LDX #1
JSR OSBYTE
CPX #0
BNE alreadycheck
:
\ patch tubexfer for Electron;
\ we do this whether we've
\ already hooked or not as
\ we need to ensure TUBEXFR is
\ correct for this hardware;
\ hope a call doesn't come in
.elkpatch
LDX #&FF
.elkpatchloop
INX
LDA elkpatchtbl,X
STA scratch
INX
LDA elkpatchtbl,X
STA scratch+1
LDY #1 : \ addr after opcode
LDA #TUBEXFERELK MOD 256
STA (scratch),Y
INY
LDA #TUBEXFERELK DIV 256
STA (scratch),Y
INX
LDA elkpatchtbl,X
BEQ elkpatchloop
:
.alreadycheck
\ check if USERV already hooked
\ which we class as >=&8000
\ (really >=&C000 =MOS)
LDA USERV+1
BMI uservhook
\ already patched - print error
BRK
EQUB 4 \ =Mistake
EQUS "USERV already hooked"
EQUB 0
:
.uservhook
\ hook USERV to catch OSWORD
PHP
SEI
LDA USERV
STA olduserv
LDA #iocode% MOD 256
STA USERV
LDA USERV+1
STA olduserv+1
LDA #iocode% DIV 256
STA USERV+1
PLP
RTS
:
.elkpatchtbl
EQUW elkpatch1
EQUB 0
EQUW elkpatch2
EQUB 0
EQUW elkpatch3
EQUB &FF
]
:
NEXT
codelen%=P%-iocode%
:
savecmd$="SAVE TubeXfrX "+STR$~(code%)+"+"+STR$~(codelen%)+" "+STR$~(exec OR &FFFF0000)+" "+STR$~(iocode% OR &FFFF0000)
PRINT "*";savecmd$
OSCLI(savecmd$)
PRINT "Done"
END
:
REM gets IO processor OSHWM
DEFFNoshwm
A%=&B4
X%=0
Y%=&FF
=USR(OSBYTE) AND &FF00
